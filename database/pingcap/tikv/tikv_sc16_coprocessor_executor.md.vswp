vnote_backup_file_826537664 /data/code/own/docs/database/pingcap/tikv/tikv_sc16_coprocessor_executor.md
# TiKV æºç è§£æç³»åˆ—æ–‡ç« ï¼ˆåå…­ï¼‰TiKV Coprocessor Executor æºç è§£æ


åœ¨å‰ä¸¤ç¯‡æ–‡ç«  [TiKV æºç è§£æç³»åˆ—æ–‡ç« ï¼ˆåå››ï¼‰Coprocessor æ¦‚è§ˆ](https://mp.weixin.qq.com/s/cdC7f9N9C88MJ_syNUg21g)ã€[TiKV æºç è§£æç³»åˆ—æ–‡ç« ï¼ˆåäº”ï¼‰è¡¨è¾¾å¼è®¡ç®—æ¡†æ¶ä¸­](https://mp.weixin.qq.com/s/UYcny9G5snh-MoMFm2qxsw)ï¼Œè®²åˆ°äº† TiDB ä¸ºäº†æœ€å¤§åŒ–åˆ©ç”¨åˆ†å¸ƒå¼è®¡ç®—èƒ½åŠ›ï¼Œä¼šå°½é‡å°† Selection ç®—å­ã€Aggregation ç®—å­ç­‰ç®—å­ä¸‹æ¨åˆ° TiKV èŠ‚ç‚¹ä¸Šï¼Œä»¥åŠä¸‹æ¨çš„è¡¨è¾¾å¼æ˜¯å¦‚ä½•åœ¨ TiKV ä¸Šåšè®¡ç®—çš„ã€‚æœ¬æ–‡å°†åœ¨å‰ä¸¤ç¯‡æ–‡ç« çš„åŸºç¡€ä¸Šï¼Œä»‹ç»ä¸‹æ¨ç®—å­çš„æ‰§è¡Œæµç¨‹å¹¶åˆ†æä¸‹æ¨ç®—å­çš„éƒ¨åˆ†å®ç°ç»†èŠ‚ï¼ŒåŠ æ·±å¤§å®¶å¯¹ TiKV Coprocessor çš„ç†è§£ã€‚

## ä»€ä¹ˆæ˜¯ä¸‹æ¨ç®—å­

ä»¥ä¸‹è¾¹çš„ `SQL` ä¸ºä¾‹å­ï¼š

```sql
select  *  from students where age >  21  limit  2

```

TiDB åœ¨è§£æå®Œè¿™æ¡ `SQL` è¯­å¥ä¹‹åï¼Œä¼šå¼€å§‹åˆ¶å®šæ‰§è¡Œè®¡åˆ’ã€‚åœ¨è¿™ä¸ªè¯­å¥ä¸­ï¼Œ TiDB ä¼šå‘ TiKV ä¸‹æ¨ä¸€ä¸ªå¯ä»¥ç”¨æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æ¥æè¿°çš„æŸ¥è¯¢è¯·æ±‚ï¼š

![å›¾ 1 DAG æ ·ä¾‹](_v_images/20200913211215124_1415110843.png)

ä»¥ä¸Šçš„ `DAG` æ˜¯ä¸€ä¸ªç”±ä¸€ç³»åˆ—ç®—å­ç»„æˆçš„æœ‰å‘æ— ç¯å›¾ï¼Œç®—å­åœ¨ TiKV ä¸­ç§°ä¸º `Executor` ã€‚æ•´ä¸ª `DAG` æè¿°äº†æŸ¥è¯¢è®¡åˆ’åœ¨ TiKV çš„æ‰§è¡Œè¿‡ç¨‹ã€‚åœ¨ä¸Šè¾¹çš„ä¾‹å­ä¸­ï¼Œä¸€æ¡æŸ¥è¯¢ `SQL` è¢«ç¿»è¯‘æˆäº†ä¸‰ä¸ªæ‰§è¡Œæ­¥éª¤ï¼š

1. æ‰«è¡¨
    
2. é€‰æ‹©è¿‡æ»¤
    
3. å–è‹¥å¹²è¡Œ
    

æœ‰äº†åŸºæœ¬æ¦‚å¿µåï¼Œä¸‹é¢æˆ‘ä»¬ç®€å•ä»‹ç»ä¸€ä¸‹è¿™æ ·çš„æŸ¥è¯¢è®¡åˆ’åœ¨ TiKV å†…éƒ¨çš„ä¸€ä¸ªæ‰§è¡Œæµç¨‹ã€‚

## ä¸‹æ¨ç®—å­å¦‚ä½•æ‰§è¡Œ

### ç»•ä¸å¼€çš„ç«å±±

TiKV æ‰§è¡Œå™¨æ˜¯åŸºäº Volcano Model ï¼ˆç«å±±æ¨¡å‹ï¼‰ï¼Œä¸€ç§ç»å…¸çš„åŸºäºè¡Œçš„æµå¼è¿­ä»£æ¨¡å‹ã€‚ç°åœ¨ä¸»æµçš„å…³ç³»å‹æ•°æ®åº“éƒ½é‡‡ç”¨äº†è¿™ç§æ¨¡å‹ï¼Œä¾‹å¦‚ Oracleï¼ŒMySQL ç­‰ã€‚

æˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªç®—å­çœ‹æˆä¸€ä¸ªè¿­ä»£å™¨ã€‚æ¯æ¬¡è°ƒç”¨å®ƒçš„ `next()` æ–¹æ³•ï¼Œæˆ‘ä»¬å°±å¯ä»¥è·å¾—ä¸€è¡Œï¼Œç„¶åå‘ä¸Šè¿”å›ã€‚è€Œæ¯ä¸ªç®—å­éƒ½æŠŠä¸‹å±‚ç®—å­çœ‹æˆä¸€å¼ è¡¨ï¼Œè¿”å›å“ªäº›è¡Œï¼Œè¿”å›æ€ä¹ˆæ ·çš„è¡Œç”±ç®—å­æœ¬èº«å†³å®šã€‚ä¸¾ä¸ªä¾‹å­ï¼š

å‡è®¾æˆ‘ä»¬ç°åœ¨å¯¹ä¸€å¼ æ²¡æœ‰ä¸»é”®ï¼Œæ²¡æœ‰ç´¢å¼•çš„è¡¨ `[1]` ï¼Œæ‰§è¡Œä¸€æ¬¡å…¨è¡¨æ‰«ææ“ä½œï¼š

```sql
select * from t where a > 2 limit 2

```

è¡¨ `[1]`ï¼š

| a `(int)` | b `(int)` |
| --- | --- |
| 3 | 1 |
| 1 | 2 |
| 5 | 2 |
| 2 | 3 |
| 1 | 4 |

é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°è¿™æ ·çš„ä¸€ä¸ªæ‰§è¡Œè®¡åˆ’ï¼š

![å›¾ 2 DAG æ‰§è¡Œæµç¨‹æ ·ä¾‹](_v_images/20200913211214722_883549853.gif)

æ¯ä¸ªç®—å­éƒ½å®ç°äº†ä¸€ä¸ª `Executor` çš„ `trait`ï¼Œ æ‰€ä»¥æ¯ä¸ªç®—å­éƒ½å¯ä»¥è°ƒç”¨ `next()` æ¥å‘ä¸Šè¿”å›ä¸€è¡Œã€‚

```rust
pub trait Executor: Send {
    fn next(&mut self) -> Result<Option<Row>>;
    // ...
}
å½“ä»¥ä¸Šçš„è¯·æ±‚è¢«è§£æä¹‹åï¼Œæˆ‘ä»¬ä¼šåœ¨ ExecutorRunner é‡Œè¾¹ä¸æ–­çš„è°ƒç”¨æœ€ä¸Šå±‚ç®—å­çš„ next() æ–¹æ³•ï¼Œ ç›´åˆ°å…¶æ— æ³•å†è¿”å›è¡Œã€‚
pub fn handle_request(&mut self) -> Result<SelectResponse> {
    loop {
        match self.executor.next()? {
            Some(row) => {
                // Do some aggregation.
            },
            None => {
                // ...
                return result;
            }
        }
    }
}

```

å¤§æ¦‚çš„é€»è¾‘å°±æ˜¯ï¼š`Runner` è°ƒç”¨ `Limit` ç®—å­çš„ `next()` æ–¹æ³•ï¼Œç„¶åè¿™ä¸ªæ—¶å€™ `Limit` å®ç°çš„ `next()` æ–¹æ³•ä¼šå»è°ƒç”¨ä¸‹ä¸€å±‚ç®—å­ `Selection` çš„ `next()` æ–¹æ³•è¦ä¸€è¡Œä¸Šæ¥åšèšåˆï¼Œç›´åˆ°è¾¾åˆ°é¢„è®¾çš„é˜€å€¼ï¼Œåœ¨ä¾‹å­ä¸­ä¹Ÿå°±æ˜¯ä¸¤è¡Œï¼Œæ¥ç€ `Selection` å®ç°çš„ `next()` åˆä¼šå»è°ƒç”¨ä¸‹ä¸€å±‚ç®—å­çš„ `next()` æ–¹æ³•ï¼Œ ä¹Ÿå°±æ˜¯ `TableScan`ï¼Œ `TableScan` çš„ `next()` å®ç°æ˜¯æ ¹æ®è¯·æ±‚ä¸­çš„ `KeyRange`ï¼Œ å‘ä¸‹è¾¹çš„ `MVCC` è¦ä¸Šä¸€è¡Œï¼Œç„¶åè¿”å›ç»™ä¸Šå±‚ç®—å­, ä¹Ÿå°±æ˜¯ç¬¬ä¸€è¡Œ `(3, 1)`ï¼Œ`Selection` æ”¶åˆ°è¡Œåæ ¹æ® `where` å­—å¥ä¸­çš„è¡¨è¾¾å¼çš„å€¼åšåˆ¤æ–­ï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶å‘ä¸Šè¿”å›ä¸€è¡Œï¼Œ å¦åˆ™ç»§ç»­é—®ä¸‹å±‚ç®—å­è¦ä¸€è¡Œï¼Œæ­¤æ—¶ `a == 3 > 2`, æ»¡è¶³æ¡ä»¶å‘ä¸Šè¿”å›ï¼Œ `Limit` æ¥æ”¶åˆ°ä¸€è¡Œåˆ™åˆ¤æ–­å½“å‰æ”¶åˆ°çš„è¡Œæ•°æ—¶å€™æ»¡ä¸¤è¡Œï¼Œä½†æ˜¯ç°åœ¨åªæ”¶åˆ°ä¸€è¡Œï¼Œæ‰€ä»¥ç»§ç»­é—®ä¸‹å±‚ç®—å­è¦ä¸€è¡Œã€‚æ¥ä¸‹æ¥ `TableScan` è¿”å› `(1,2), Selection` å‘ç°ä¸æ»¡è¶³æ¡ä»¶ï¼Œç»§ç»­é—® `TableScan` è¦ä¸€è¡Œä¹Ÿå°±æ˜¯ `(5,2), Selection` å‘ç°è¿™è¡Œæ»¡è¶³æ¡ä»¶ï¼Œç„¶åè¿”å›è¿™ä¸€è¡Œï¼Œ`Limit` æ¥æ”¶åˆ°ä¸€è¡Œï¼Œç„¶ååœ¨ä¸‹ä¸€æ¬¡è°ƒç”¨å…¶ `next()` æ–¹æ³•æ—¶ï¼Œå‘ç°æ¥æ”¶åˆ°çš„è¡Œæ•°å·²ç»æ»¡ä¸¤è¡Œï¼Œæ­¤æ—¶è¿”å› `None`ï¼Œ `Runner` ä¼šå¼€å§‹å¯¹ç»“æœå¼€å§‹èšåˆï¼Œç„¶ä¼šè¿”å›ä¸€ä¸ªå“åº”ç»“æœã€‚

### å¼•å…¥å‘é‡åŒ–çš„æŸ¥è¯¢å¼•æ“

å½“å‰ TiKV å¼•å…¥äº†å‘é‡åŒ–çš„æ‰§è¡Œå¼•æ“ï¼Œæ‰€è°“çš„å‘é‡åŒ–ï¼Œå°±æ˜¯åœ¨ `Executor` é—´ä¼ é€’çš„ä¸å†æ˜¯å•å•çš„ä¸€è¡Œï¼Œè€Œæ˜¯å¤šè¡Œï¼Œæ¯”å¦‚ `TableScan` åœ¨åº•å±‚ `MVCC Snapshot` ä¸­æ‰«ä¸Šæ¥çš„ä¸å†æ˜¯ä¸€è¡Œï¼Œè€Œæ˜¯è¯´å¤šè¡Œã€‚è‡ªç„¶çš„ï¼Œåœ¨ç®—å­æ‰§è¡Œè®¡ç®—ä»»åŠ¡çš„æ—¶å€™ï¼Œè®¡ç®—çš„å•å…ƒä¹Ÿä¸å†æ˜¯ä¸€ä¸ªæ ‡é‡ï¼Œè€Œæ˜¯ä¸€ä¸ªå‘é‡ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå½“é‡åˆ°ä¸€ä¸ªè¡¨è¾¾å¼ï¼š`a + b` çš„æ—¶å€™ï¼Œ æˆ‘ä»¬ä¸æ˜¯è®¡ç®—ä¸€è¡Œé‡Œè¾¹ `a` åˆ—å’Œ `b` åˆ—ä¸¤ä¸ªæ ‡é‡ç›¸åŠ çš„ç»“æœï¼Œè€Œæ˜¯è®¡ç®— `a` åˆ—å’Œ `b` åˆ—ä¸¤åˆ—ç›¸åŠ çš„ç»“æœã€‚

![å›¾ 3 å‘é‡åŒ–è®¡ç®—æ¨¡å‹ä¸æ ‡é‡è®¡ç®—æ¨¡å‹å¯¹æ¯”](_v_images/20200913211214320_1838683344.png)

ä¸ºä»€ä¹ˆè¦å¼•å…¥å‘é‡åŒ–æ¨¡å‹å‘¢ï¼ŒåŸå› æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š

1. å¯¹äºæ¯è¡Œæˆ‘ä»¬è‡³å°‘å¾—è°ƒç”¨ 1 æ¬¡ `next()` æ–¹æ³•ï¼Œå¦‚æœ `DAG` çš„æœ€å¤§æ·±åº¦å¾ˆæ·±ï¼Œä¸ºäº†è·å–ä¸€è¡Œæˆ‘ä»¬éœ€è¦è°ƒç”¨æ›´å¤šæ¬¡çš„ `next()` æ–¹æ³•ï¼Œæ‰€ä»¥åœ¨ä¼ ç»Ÿçš„è¿­ä»£æ¨¡å‹ä¸­ï¼Œè™šå‡½æ•°è°ƒç”¨çš„å¼€é”€éå¸¸å¤§ã€‚å¦‚æœä¸€æ¬¡ `next()` æ–¹æ³•å°±è¿”å›å¤šè¡Œï¼Œè¿™æ ·å¹³å‡ä¸‹æ¥æ¯æ¬¡ `next()` æ–¹æ³•å°±å¯ä»¥è¿”å›å¤šè¡Œï¼Œè€Œä¸æ˜¯è‡³å¤šä¸€è¡Œã€‚
    
2. ç”±äºè¿­ä»£çš„å¼€é”€éå¸¸å¤§ï¼Œæ•´ä¸ªæ‰§è¡Œçš„å¾ªç¯æ— æ³•è¢« `loop-pipelining` ä¼˜åŒ–ï¼Œä½¿å¾—æ•´ä¸ªå¾ªç¯æµæ°´çº¿è¢«å¡æ­»ï¼ŒIPC å¤§å¤§ä¸‹é™ã€‚è¿”å›å¤šè¡Œä¹‹åï¼Œæ¯ä¸ªç®—å­å†…éƒ¨å¯ä»¥é‡‡ç”¨å¼€é”€è¾ƒå°çš„å¾ªç¯ï¼Œæ›´å¥½åˆ©ç”¨ `loop-pipelining` ä¼˜åŒ–ã€‚
    

å½“ç„¶å‘é‡åŒ–æ¨¡å‹ä¹Ÿä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ï¼š

1. åŸå…ˆæœ€ä¸Šå±‚ç®—å­æŒ‰éœ€å‘ä¸‹å±‚ç®—å­æ‹¿ä¸Šä¸€è¡Œï¼Œè€Œç°åœ¨æ‹¿ä¸Šå¤šè¡Œï¼Œå†…å­˜å¼€é”€è‡ªç„¶ä¼šå¢åŠ ã€‚
    
2. è®¡ç®—æ¨¡å‹å‘ç”Ÿå˜åŒ–ï¼ŒåŸæ¥åŸºäºæ ‡é‡è®¡ç®—çš„è¡¨è¾¾å¼æ¡†æ¶éœ€è¦é‡æ„ ï¼ˆè¯¦è§ä¸Šç¯‡æ–‡ç« ï¼‰ã€‚
    

ä½†æ˜¯è¿™æ ·å¹¶ä¸å½±å“å‘é‡åŒ–æŸ¥è¯¢å¸¦æ¥çš„æ˜¾è‘—çš„æ€§èƒ½æå‡ï¼Œä¸‹è¾¹æ˜¯å¼•å…¥å‘é‡åŒ–æ¨¡å‹åä¸€ä¸ªåŸºå‡†æµ‹è¯•ç»“æœï¼šï¼ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒCoprocessor è®¡ç®—è¿˜åªæ˜¯ TPC-H ä¸­çš„å…¶ä¸­ä¸€éƒ¨åˆ†ï¼Œæ‰€ä»¥è®¡ç®—ä»»åŠ¡æ¯”é‡å¾ˆå¤§ç¨‹åº¦ä¸Šå†³å®šäº†å¼€ä¸å¼€å‘é‡åŒ–å¸¦æ¥çš„æå‡æ¯”ä¾‹ï¼‰ã€‚

![å›¾ 4 å‘é‡åŒ–æŸ¥è¯¢å¼•æ“benchmark](_v_images/20200913211213916_2049030494.png)

å¼•å…¥å‘é‡åŒ–æ¨¡å‹åï¼ŒåŸå…ˆçš„ `Execturor` trait å°±å˜æˆäº† `BatchExecutor`ï¼Œ å¯¹åº”çš„ `next()` æ–¹æ³•å°±æˆäº† `next_batch()`ã€‚ è‡ªç„¶çš„ `next_batch` ä¸å†è¿”å›ä¸€ä¸ªè¡Œï¼Œè€Œæ˜¯ä¸€ä¸ª `BatchExecuteResult`ï¼Œä¸Šè¾¹è®°å½•äº†æ‰«ä¸Šæ¥çš„ä¸€å¼ è¡¨ `physical_columns`ï¼Œä»¥åŠå­è¡¨ä¸­å“ªäº›è¡Œåº”å½“è¢«ä¿ç•™çš„ `logical_rows` å’Œä¸€ä¸ª `is_drain` ç”¨æ¥è¡¨ç¤ºä¸‹å±‚ç®—å­æ˜¯å¦å·²ç»æ²¡æœ‰æ•°æ®å¯ä»¥è¿”å›ã€‚

```rust
pub trait BatchExecutor: Send {

    /// è·å–è¡¨çš„ `schema`
    fn schema(&self) -> &[FieldType];

    // å‘ä¸‹å±‚ç®—å­è¦å›ä¸€å¼ è¡¨
    fn next_batch(&mut self, scan_rows: usize) -> BatchExecuteResult;

    // ...
}

pub struct BatchExecuteResult {
    // æœ¬è½®å¾ªç¯ `TableScan` æ‰«ä¸Šæ¥çš„æ•°æ®
    pub physical_columns: LazyBatchColumnVec,

    /// è®°å½• `physical_columns` ä¸­æœ‰æ•ˆçš„è¡Œçš„ä¸‹æ ‡
    pub logical_rows: Vec<usize>,

    // ...

    // è¡¨ç¤ºä¸‹å±‚ç®—å­æ˜¯å¦å·²ç»æ²¡æœ‰æ•°æ®å¯ä»¥è¿”å›
    pub is_drained: Result<bool>,
}

```

åœ¨æ¥ä¸‹æ¥çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç®€å•ä»‹ç»ä¸€ä¸‹å‡ ç§å…¸å‹ç®—å­çš„å®ç°ç»†èŠ‚ï¼Œæ—¨åœ¨è®©å¤§å®¶æ›´åŠ ç†Ÿæ‚‰å„ä¸ªç®—å­çš„å·¥ä½œåŸç†ã€‚

## å…¸å‹ç®—å­çš„å®ç°

### `BatchTableScanExecutor` çš„å®ç°

é¦–å…ˆæˆ‘ä»¬å…ˆæ˜ç¡®ä¸€ä¸‹ `BatchTableScanExecutor` çš„åŠŸèƒ½ï¼Œ`TableScan` å®ç°çš„ `next_batch()` æ¯è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œå®ƒå°±ä¼šä»åº•å±‚çš„å®ç°äº† `Storage trait` çš„å­˜å‚¨å±‚ä¸­æ‰«ä¸ŠæŒ‡å®šçš„è¡Œæ•°ï¼Œä¹Ÿå°±æ˜¯ `scan_rows` è¡Œã€‚ä½†æ˜¯ç”±äºæˆ‘ä»¬åœ¨è®¡ç®—çš„æ—¶å€™æ˜¯é‡‡ç”¨å‘é‡åŒ–çš„è®¡ç®—æ¨¡å‹ï¼Œè®¡ç®—éƒ½æ˜¯åŸºäºåˆ—è¿›è¡Œçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šå¯¹æ‰«ä¸Šæ¥çš„è¡Œè¿›è¡Œä¸€æ¬¡è¡Œåˆ—è½¬æ¢ï¼Œå°†è¡¨ä»è¡Œå­˜æ ¼å¼è½¬æ¢æˆåˆ—å­˜æ ¼å¼ã€‚

![å›¾ 5 è¡Œå­˜è½¬åˆ—å­˜](_v_images/20200913211213613_1399875006.png)

æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹ [`BatchTableScanExecutor`](https://github.com/tikv/tikv/blob/96c3f978f655148b1703a520cb9b2e9001dd256d/components/tidb_query/src/batch/interface.rs#L19) ç°åœ¨çš„å®šä¹‰ï¼š

```rust
pub struct BatchTableScanExecutor<S: Storage>(ScanExecutor<S, TableScanExecutorImpl>);

```

ä»ç»“æ„ä½“çš„å®šä¹‰ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œ`BatchTableScanExecutor` ä¾èµ–äº `ScanExecutor`ï¼Œè€Œè¿™ä¸ª `ScanExecutor` ä¾èµ–äºä¸€ä¸ªå®ç° `Storage` çš„ç±»å‹å’Œå…·ä½“ `TableScanExecutorImpl`ã€‚

å…¶ä¸­ [`ScanExecutor`](https://github.com/tikv/tikv/blob/96c3f978f655148b1703a520cb9b2e9001dd256d/components/tidb_query/src/batch/executors/util/scan_executor.rs#L38) æ˜¯ä¸€ä¸ªé€šç”¨çš„ç»“æ„ä½“ï¼Œå…¶ä½œç”¨æ˜¯ä¸ºäº†æŠ½è±¡å‡ºæ‰«è¡¨å’Œæ‰«ç´¢å¼•ä¸¤ç§æ“ä½œï¼Œè¿™ä¸¤ç§æ“ä½œéƒ½éœ€è¦ä¾èµ–ä¸€ä¸ª `Storage` è€ŒåŒºåˆ«ä»–ä»¬å…·ä½“è¡Œä¸ºçš„æ˜¯ä¸€ä¸ªå®ç°äº† `ScanExecutorImpl` çš„ç»“æ„ä½“ï¼Œåœ¨ä¸Šè¾¹çš„å®šä¹‰ä¸­å°±æ˜¯ï¼š`TableScanExecutorImpl`ã€‚

```rust
pub struct ScanExecutor<S: Storage, I: ScanExecutorImpl> {
    /// å…·ä½“çš„æ‰«è¡¨/æ‰«ç´¢å¼•å®ç°ã€‚
    imp: I,

    /// ç»™å®šä¸€ä¸ª `KeyRange`ï¼Œæ‰«ä¸Šä¸€è¡Œæˆ–è€…å¤šè¡Œã€‚
    scanner: RangesScanner<S>,

    // æ ‡è®°æ˜¯å¦å·²ç»æ‰«å®Œäº†æ‰€æœ‰çš„è¡Œã€‚
    is_ended: bool,
}

```

`BatchTableScanExecutor` ä¸­æˆ‘ä»¬éœ€è¦é‡ç‚¹å…³æ³¨çš„æ˜¯å…¶å®ç°çš„ `BatchExecutor`, å…¶ä¸­æœ€ä¸ºå…³é”®çš„å°±æ˜¯ `next_batch()`ï¼Œç„¶è€Œå…¶ä¾èµ–äºå†…éƒ¨ `ScanExecutor` çš„ `BatchExecutor` å®ç°ï¼Œä¹Ÿå°±æ˜¯ï¼š

```rust
    fn next_batch(&mut self, scan_rows: usize) -> BatchExecuteResult {

        // åˆ›å»ºä¸€ä¸ªåˆ—æ•°ç»„
        let mut logical_columns = self.imp.build_column_vec(scan_rows);
        
        // æ‰«ä¸Š `scan_rows` è¡Œï¼Œ ç„¶åæŒ‰åˆ—å¡«å……åˆ°åˆ›å»ºå¥½çš„åˆ—æ•°ç»„ä¸­ã€‚
        let is_drained = self.fill_column_vec(scan_rows, &mut logical_columns);

        // åˆ›å»ºä¸€ä¸ª `logical_rows`, è¡¨ç¤ºå½“å‰è¡¨ä¸­æ‰€æœ‰è¡Œæœ‰æ•ˆã€‚åè¾¹å¯èƒ½æ ¹æ® `Selection` çš„ç»“æœä¿®æ”¹è¿™ä¸ª `logical_rows`ã€‚
        let logical_rows = (0..logical_columns.rows_len()).collect();

        // åˆ¤æ–­æ˜¯å¦æ‰«å®Œä¼ å…¥çš„ `KeyRange`
        match &is_drained {
            // Note: `self.is_ended` is only used for assertion purpose.
            Err(_) | Ok(true) => self.is_ended = true,
            Ok(false) => {}
        };

        // è¿”å› `BatchExecuteResult`
        BatchExecuteResult {
            // ...
        }
    }

```

å€¼å¾—æ³¨æ„çš„æ˜¯ä¸Šè¾¹ `fill_column_vec` çš„å®ç°, å®ƒå¤§æ¦‚çš„é€»è¾‘å°±æ˜¯æ¯æ¬¡é—® `self.scanner` è¦ä¸Šä¸€ä¸ª `Key-Value` å¯¹, ç„¶åæ‰”ç»™ `self.imp.process_kv_pair` å¤„ç†ï¼Œåœ¨æ‰«è¡¨çš„å®ç°ä¸­å°±æ˜¯å°† `value` çœ‹æˆæ˜¯ä¸€ä¸ªè¡Œçš„ `datum` ç¼–ç ï¼Œç„¶åå°†æ¯åˆ—çš„æ•°æ®è§£å‡ºæ¥ç„¶åæ”¾åˆ°å»ºå¥½çš„åˆ—æ•°ç»„é‡Œè¾¹å»ã€‚

```rust
    fn fill_column_vec(
        &mut self,
        scan_rows: usize,
        columns: &mut LazyBatchColumnVec,
    ) -> Result<bool> {
        assert!(scan_rows > 0);

        for _ in 0..scan_rows {
            let some_row = self.scanner.next()?;
            if let Some((key, value)) = some_row {
                // å°†æ‰«ä¸Šæ¥çš„ä¸€è¡Œæ”¾å…¥ `columns` ä¸­
                self.imp.process_kv_pair(&key, &value, columns)?;
            } else {
                // æ²¡æœ‰ `KeyRange` å¯ä¾›æ‰«æï¼Œå·²ç»å®Œæˆæ‰«è¡¨ã€‚
                return Ok(true);
            }
        }

        // è¡¨ç¤ºä¸‹å±‚æ•°æ®è¿˜æ²¡æœ‰æ‰«å®Œã€‚
        Ok(false)
    }

```

**å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç°åœ¨è¡¨ä¸­çš„æ•°æ®éƒ½æ˜¯æœªç»è§£ç çš„ç”Ÿæ•°æ®ï¼Œæ‰€è°“çš„ç”Ÿæ•°æ®å°±æ˜¯è¿˜ä¸èƒ½ç›´æ¥å‚ä¸åˆ°è¡¨è¾¾å¼è®¡ç®—çš„æ•°æ®ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ˜¯ä¸€ç§ lazy decoding çš„ç­–ç•¥ï¼Œåªæœ‰è¦å‚ä¸è®¡ç®—çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰ä¼šè§£ç ç‰¹å®šçš„åˆ—ï¼Œè€Œä¸æ˜¯å°†æ•°æ®æ‰«ä¸Šæ¥å°±å¼€å§‹è§£ç æ•°æ®ï¼Œå°†å…¶å˜æˆèƒ½å¤Ÿç›´æ¥å‚ä¸è®¡ç®—çš„ç»“æ„ã€‚**

### `BatchSelectionExecutor` çš„å®ç°

æ¥ä¸‹æ¥è¦ä»‹ç»çš„æ˜¯ [`BatchSelectionExecutor`](https://github.com/tikv/tikv/blob/96c3f978f655148b1703a520cb9b2e9001dd256d/components/tidb_query/src/batch/executors/selection_executor.rs#L17) çš„å®ç°ï¼Œæˆ‘ä»¬é¦–å…ˆæ¥çœ‹çœ‹å®šä¹‰ï¼š

```rust
pub struct BatchSelectionExecutor<Src: BatchExecutor> {
    // ...
    
    // æ•°æ®æº
    src: Src,

    // æ¡ä»¶è¡¨è¾¾å¼
    conditions: Vec<RpnExpression>,
}

```

é¦–å…ˆï¼Œ `BatchSelectionExecutor` éœ€è¦ä¾èµ–ä¸€ä¸ª `Src`ï¼Œä¸€ä¸ª `BatchExecutor` æ¥æä¾›æ•°æ®çš„æ¥æºï¼Œç„¶åæ˜¯ä¸€ç»„æ¡ä»¶è¡¨è¾¾å¼ï¼Œå½“ `BatchSelectionExecutor` åœ¨æ‰§è¡Œçš„æ—¶å€™ä¼šå¯¹è¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ï¼Œç„¶åæ ¹æ®æ±‚å‡ºçš„å€¼å¯¹ä¸‹å±‚æ•°æ®æ‹‰ä¸Šæ¥çš„è¡Œåšè¿‡æ»¤èšåˆï¼Œç„¶åè¿”å›è¿‡æ»¤å‡ºçš„è¡Œã€‚

è§‚å¯Ÿ `BatchSelectionExecutor` å®ç°çš„ `BatchExecutor` å¯ä»¥å‘ç°ï¼Œå…¶ä¸­çš„ `next_batch()` æ–¹æ³•ä¾èµ–äº `handle_src_result()`ï¼š

```rust
    #[inline]
    fn next_batch(&mut self, scan_rows: usize) -> BatchExecuteResult {
        // ä»ä¸‹å±‚ç®—å­é‚£ä¼šä¸€å—æ•°æ®å¼€å§‹è¿‡æ»¤
        let mut src_result = self.src.next_batch(scan_rows);

        // æ ¹æ®è¡¨è¾¾å¼çš„å€¼ï¼Œè¿‡æ»¤å‡ºå¯¹åº”çš„è¡Œã€‚
        if let Err(e) = self.handle_src_result(&mut src_result) {
            src_result.is_drained = src_result.is_drained.and(Err(e));
            src_result.logical_rows.clear();
        } else {
            // ... 
        }

        src_result

```

é€šè¿‡è§‚å¯Ÿ `handle_src_result` çš„å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå®ƒä¼šéå†æ‰€æœ‰è¡¨è¾¾å¼ï¼Œå¯¹å…¶æ±‚å€¼ï¼Œè¡¨è¾¾å¼çš„å€¼å¯èƒ½æ˜¯ä¸€ä¸ªæ ‡é‡ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªå‘é‡ï¼Œä½†æ˜¯æˆ‘ä»¬å®Œå…¨æ˜¯å¯ä»¥æŠŠæ ‡é‡çœ‹æˆæ˜¯æ¯è¡Œéƒ½ä¸€æ ·çš„å‘é‡ï¼Œç„¶åæ ¹æ®æ¯è¡Œçš„å€¼ï¼Œå°†å…¶è½¬æ¢æˆ `bool`ï¼Œå¦‚æœè¯¥è¡Œçš„å€¼ä¸º `true`ï¼Œåˆ™åœ¨ `logical_rows` ä¸­ä¿ç•™ä»–çš„ä¸‹æ ‡ã€‚

```rust
    fn handle_src_result(&mut self, src_result: &mut BatchExecuteResult) -> Result<()> {
        let mut src_logical_rows_copy = Vec::with_capacity(src_result.logical_rows.len());
        let mut condition_index = 0;
        while condition_index < self.conditions.len() && !src_result.logical_rows.is_empty() {
            // æ‹·è´ä¸€ä»½ä¸‹å±‚ç®—å­çš„ `logical_rows`ï¼Œç”¨åšè®¡ç®—è¡¨è¾¾å¼ã€‚
            src_logical_rows_copy.clear();
            src_logical_rows_copy.extend_from_slice(&src_result.logical_rows);

            // è®¡ç®—è¡¨è¾¾å¼çš„å€¼ï¼Œç„¶åæ ¹æ®è¡¨è¾¾å¼çš„å€¼å»æ›´æ–°ä¸‹å±‚ç®—å­çš„ `logical_rows`ã€‚
            match self.conditions[condition_index].eval(
                &mut self.context,
                self.src.schema(),
                &mut src_result.physical_columns,
                &src_logical_rows_copy,
                // è¡¨è¾¾å¼äº§ç”Ÿçš„ç»“æœå¦‚æœæ˜¯ä¸€åˆ—çš„è¯, è¿™é‡Œè¡¨ç¤ºè¡¨è¾¾å¼åº”è¯¥è¾“å‡ºçš„è¡Œæ•°
                src_logical_rows_copy.len(),
            )? {
                RpnStackNode::Scalar { value, .. } => {
                    // å¦‚æœè¡¨è¾¾å¼æ˜¯ä¸€ä¸ªæ ‡é‡ï¼Œæ ¹æ®è½¬æ¢æˆ `bool` çš„å€¼ç¡®å®šæ˜¯å¦ä¿ç•™è¯¥åˆ—ã€‚
                    update_logical_rows_by_scalar_value(
                        &mut src_result.logical_rows,
                        &mut self.context,
                        value,
                    )?;
                }
                RpnStackNode::Vector { value, .. } => {
                    // æ ¹æ®æ¯è¡Œçš„ç»“æœï¼Œç¡®å®šæ˜¯å¦ä¿ç•™é‚£è¡Œã€‚
                    update_logical_rows_by_vector_value(
                    &mut src_result.logical_rows,
                    &mut self.context,
                    eval_result,
                    eval_result_logical_rows,
                    )?;
                }
            }

            condition_index += 1;
        }

        Ok(())
    }
}

```

### `BatchFastHashAggregationExecutor` çš„å®ç°

èšåˆç®—å­çš„ç§ç±»æœ‰å¾ˆå¤šç§ï¼ŒåŒ…æ‹¬ï¼š

1. `SimpleAggregation` (æ²¡æœ‰ `group by` å­—å¥ï¼Œåªæœ‰èšåˆå‡½æ•°)

- =\> `select count(*) from t where a > 1`

2. `FastHashAggregation` (åªæœ‰ä¸€ä¸ª `group by` column)

- =\> `select count(*) from t group by a`

3. `SlowHashAggregation` (å¤šä¸ª `groub by` columns, æˆ–è€…è¡¨è¾¾å¼å€¼ä¸æ˜¯ `Hashable` çš„)

- =\> `select sum(*) from t group by a, b`

4. `StreamAggregation` è¿™ç§èšåˆç®—å­å‡è®¾è¾“å…¥å·²ç»æŒ‰ç…§ `group by` columns æ’å¥½åºã€‚

æˆ‘ä»¬è¿™é‡ŒæŒ‘å‡ºä¸€ä¸ªæ¯”è¾ƒå…·æœ‰ä»£è¡¨æ€§çš„ç®—å­ï¼š`BatchFastHashAggregationExecutor` æ¥è¿›è¡Œåˆ†æã€‚

é¦–å…ˆè¦æ˜ç¡®ä¸€ä¸‹ `BatchFastHashAggregationExecutor` å¤§è‡´çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œé¦–å…ˆæˆ‘ä»¬ä¼šæ ¹æ® `group by` column é‡Œè¾¹çš„å€¼ç»™ä¸‹å±‚ç®—å­è¿”å›çš„è¡¨è¿›è¡Œåˆ†ç»„ï¼Œæ¯”å¦‚ï¼š

```sql
select count(*) from t group by a

```

![å›¾ 6 æ ¹æ® a åˆ—çš„å€¼å¯¹è¡Œè¿›è¡Œåˆ†ç»„](_v_images/20200913211213210_1524844554.png)

ç„¶åï¼Œæˆ‘ä»¬ä¼šéå†æ¯ä¸ªç»„ï¼Œç„¶åé’ˆå¯¹æ¯ä¸ªç»„æ±‚å‡ºæ¯ä¸ªèšåˆå‡½æ•°çš„å€¼ï¼Œåœ¨è¿™é‡Œå°±æ˜¯ï¼š

![å›¾ 7 éå†æ¯ä¸ªç»„æ±‚å‡ºèšåˆå‡½æ•°çš„å€¼](_v_images/20200913211212907_1823159916.png)

æ¥ä¸‹æ¥å°±æ¶‰åŠåˆ°ä¸¤ä¸ªé‡è¦çš„ç»†èŠ‚ï¼š

1. èšåˆå‡½æ•°å¦‚ä½•æ±‚å€¼ã€‚
    
2. å¦‚ä½•æ ¹æ® `group_by column` å¯¹è¡Œè¿›è¡Œåˆ†ç»„å¹¶èšåˆã€‚
    

åç»­å‡ èŠ‚æˆ‘ä»¬ç€é‡ä»‹ç»ä¸€ä¸‹è¿™ä¸¤ä¸ªç»†èŠ‚æ˜¯å¦‚ä½•å®ç°çš„ã€‚

#### èšåˆå‡½æ•°

æ¯ä¸ªèšåˆå‡½æ•°éƒ½ä¼šå®ç°ä¸€ä¸ª [`AggrFunction`](https://github.com/tikv/tikv/blob/96c3f978f655148b1703a520cb9b2e9001dd256d/components/tidb_query/src/aggr_fn/mod.rs#L35) è¿™ä¸ª traitï¼š

```rust
pub trait AggrFunction: std::fmt::Debug + Send + 'static {
    /// The display name of the function.
    fn name(&self) -> &'static str;

    /// Creates a new state instance. Different states aggregate independently.
    fn create_state(&self) -> Box<dyn AggrFunctionState>;
}

// NOTE: AggrFunctionState æ˜¯ AggrFunctionStateUpdatePartial çš„ super trait
pub trait AggrFunctionState:
    std::fmt::Debug
    + Send
    + 'static
    + AggrFunctionStateUpdatePartial<Int>
    + AggrFunctionStateUpdatePartial<Real>
    + AggrFunctionStateUpdatePartial<Decimal>
    + AggrFunctionStateUpdatePartial<Bytes>
    + AggrFunctionStateUpdatePartial<DateTime>
    + AggrFunctionStateUpdatePartial<Duration>
    + AggrFunctionStateUpdatePartial<Json>
{
    fn push_result(&self, ctx: &mut EvalContext, target: &mut [VectorValue]) -> Result<()>;
}
pub trait AggrFunctionStateUpdatePartial<T: Evaluable> {
    fn update(&mut self, ctx: &mut EvalContext, value: &Option<T>) -> Result<()>;

    fn update_repeat(
        &mut self,
        ctx: &mut EvalContext,
        value: &Option<T>,
        repeat_times: usize,
    ) -> Result<()>;

    fn update_vector(
        &mut self,
        ctx: &mut EvalContext,
        physical_values: &[Option<T>],
        logical_rows: &[usize],
    ) -> Result<()>;
}

```

èšåˆå‡½æ•°çš„æ±‚å€¼è¿‡ç¨‹åˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ï¼š

1. åˆ›å»ºå¹¶åˆå§‹åŒ–çŠ¶æ€ï¼Œè¿™ä¸€è¿‡ç¨‹ä¸€èˆ¬æ˜¯ç”±è°ƒç”¨è€…è°ƒç”¨ï¼š`create_state` å®ç°çš„ã€‚
    
2. ç„¶ååœ¨ä¸æ–­éå†è¡Œ/å‘é‡çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šå°†è¡Œçš„å†…å®¹ä¼ å…¥ `update/update_repeat/update_vector` å‡½æ•°(å…·ä½“è°ƒç”¨é‚£ç§å–å†³äºä¸åŒçš„èšåˆå‡½æ•°å®ç°)ï¼Œæ›´æ–°å†…éƒ¨çš„çŠ¶æ€ï¼Œæ¯”å¦‚é‡åˆ°ä¸€ä¸ªéç©ºè¡Œï¼Œ`COUNT()` å°±ä¼šç»™è‡ªå·±å†…éƒ¨è®¡æ•°å™¨+1ã€‚
    
3. å½“éå†ç»“æŸä¹‹åï¼Œèšåˆå‡½æ•°å°±ä¼šå°†è‡ªå·±çš„çŠ¶æ€é€šè¿‡ push_result(), å†™å…¥åˆ°ä¸€ä¸ªåˆ—æ•°ç»„é‡Œè¾¹ï¼Œè¿™é‡Œä¹‹æ‰€ä»¥æ˜¯åˆ—æ•°ç»„æ˜¯å› ä¸ºèšåˆå‡½æ•°å¯èƒ½æœ‰å¤šä¸ªè¾“å‡ºåˆ—ï¼Œæ¯”å¦‚ AVG()ï¼Œåœ¨åˆ†å¸ƒå¼çš„åœºæ™¯ï¼Œæˆ‘ä»¬éœ€è¦è¿”å›ä¸¤åˆ—ï¼š`SUM` å’Œ `COUNT`ã€‚
    

è¿™ä¸ª `trait` å¯ä»¥é€šè¿‡ `#[derive(AggrFuntion)]` è‡ªåŠ¨æ¨å¯¼å‡ºå®ç°ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡è¿‡ç¨‹å® `#[aggr_funtion(state = FooState::new())]` æ¥æŒ‡å®š `create_state` åˆ›å»ºå‡ºæ¥çš„ `State` ç±»å‹ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œ`COUNT` çš„å®ç°ï¼š

```rust
/// The COUNT aggregate function.
#[derive(Debug, AggrFunction)]
#[aggr_function(state = AggrFnStateCount::new())]
pub struct AggrFnCount;

/// The state of the COUNT aggregate function.
#[derive(Debug)]
pub struct AggrFnStateCount {
    count: usize,
}

impl AggrFnStateCount {
    pub fn new() -> Self {
        Self { count: 0 }
    }
}

impl AggrFunctionStateUpdatePartial for AggrFnStateCount { /* .. */ }
impl AggrFunctionState for AggrFnStateCount { /* .. */ }

```

è¿™ä¸ªæ—¶å€™ï¼Œè°ƒç”¨ `create_state()` çš„æ—¶å€™å°±ä¼šå°†å†…éƒ¨çŠ¶æ€ Box èµ·æ¥ç„¶åè¿”å›ã€‚

#### å¦‚ä½•æ ¹æ® `group by` column åˆ†ç»„å¹¶èšåˆ

`BatchFastHashAggregationExecutor` å†…éƒ¨ä¼šæœ‰ä¸€ä¸ª `Groups` çš„ç»“æ„ï¼Œå…¶æ ¸å¿ƒæ˜¯ä¸€ä¸ª `HashTable`ï¼Œæ ¹æ® `group by` è¡¨è¾¾å¼å…·ä½“çš„ç±»å‹ä½œä¸º `key` çš„ç±»å‹ï¼Œè€Œ `value` çš„å€¼åˆ™æ˜¯ä¸€ä¸ª `AggrFunctionState` æ•°ç»„ä¸­è¯¥ç»„å¯¹åº”çš„èšåˆå‡½æ•°çŠ¶æ€é›†åˆçš„å¼€å§‹ä¸‹æ ‡ã€‚ä¸¾ä¸ªä¾‹å­ï¼š

![å›¾ 8 éå†æ‰€æœ‰èšåˆå‡½æ•°åˆ›å»ºçš„çŠ¶æ€](_v_images/20200913211212504_264953653.png)

`Hash` å€¼ä¸€æ ·çš„è¡Œä¼šè¢«åˆ†é…åˆ°åŒä¸€ä¸ªç»„ä¸­ï¼Œæ¯ç»„ä¼šæœ‰è‹¥å¹²ä¸ªçŠ¶æ€ï¼Œèšåˆçš„è¿‡ç¨‹å…¶å®å°±æ˜¯æ ¹æ®æ¯è¡Œçš„ `group by` column æ‰¾åˆ°å…¶å¯¹åº”çš„åˆ†ç»„ (HashTable::get)ï¼Œç„¶åå¯¹ç»„å†…çš„æ¯ä¸€ä¸ªçŠ¶æ€ï¼Œæ ¹æ®è¯¥è¡Œçš„å†…å®¹è¿›è¡Œæ›´æ–°ã€‚æœ€åéå†æ¯ä¸ªç»„ï¼Œå°†ä»–ä»¬çš„çŠ¶æ€å†™å…¥åˆ°åˆ—æ•°ç»„å³å¯ã€‚

#### å°†ä¸¤ä¸ªè¿‡ç¨‹ç»“åˆèµ·æ¥

ä¸Šè¾¹ä¸¤èŠ‚è®¨è®ºäº†èšåˆå‡½æ•°å¦‚ä½•è®¡ç®—ï¼Œå¦‚ä½•åˆ†ç»„ä»¥åŠå¦‚ä½•å¯¹æ¯ä¸ªç»„åšèšåˆçš„åŸºæœ¬è¿‡ç¨‹ã€‚ç°åœ¨æˆ‘ä»¬é€šè¿‡ä»£ç ï¼Œæ¥æ¢è®¨ä¸€ä¸‹å…¶ä¸­çš„å…·ä½“ç»†èŠ‚ã€‚

å…ˆæ¥çœ‹çœ‹ [`BatchFastHashAggregationExecutor`](https://github.com/tikv/tikv/blob/96c3f978f655148b1703a520cb9b2e9001dd256d/components/tidb_query/src/batch/executors/fast_hash_aggr_executor.rs#L34) çš„å®šä¹‰:

```rust
pub struct BatchFastHashAggregationExecutor<Src: BatchExecutor>(
    AggregationExecutor<Src, FastHashAggregationImpl>,
);

```

æˆ‘ä»¬å‘ç°ï¼Œè¿™ä¸ªå’Œ `BatchTableScanExecutor` çš„å®šä¹‰ååˆ†ç›¸ä¼¼ï¼ŒåŒºåˆ«æ¯ä¸ªèšåˆç®—å­è¡Œä¸ºçš„æ˜¯ `AggregationExecutor` é‡Œè¾¹å®ç°äº† `AggregationExecutorImpl` trait çš„ä¸€ä¸ªç»“æ„ä½“ã€‚ æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹çœ‹è¿™ä¸ª trait æä¾›äº†å“ªäº›æ–¹æ³•ã€‚

```rust
pub struct AggregationExecutor<Src: BatchExecutor, I: AggregationExecutorImpl<Src>> {
    imp: I,
    is_ended: bool,
    entities: Entities<Src>,
}

pub trait AggregationExecutorImpl<Src: BatchExecutor>: Send {
    // æ ¹æ® `group by` columns å’Œ èšåˆå‡½æ•°åˆå§‹åŒ– `entities` ä¸­çš„ `schema`
    fn prepare_entities(&mut self, entities: &mut Entities<Src>);

    // æ ¹æ®ä¸‹å±‚ç®—å­æ‰«ä¸Šæ¥çš„æ•°æ®åšèšåˆå’Œåˆ†ç»„
    fn process_batch_input(
        &mut self,
        entities: &mut Entities<Src>,
        input_physical_columns: LazyBatchColumnVec,
        input_logical_rows: &[usize],
    ) -> Result<()>;

    // å°†æ¯ä¸ªèšåˆå‡½æ•°çš„çŠ¶æ€æ›´æ–°åˆ°åˆ—æ•°ç»„ä¸­ï¼Œå³å†™å…¥èšåˆç»“æœ
    // è¿™é‡Œè¿”å›çš„æ˜¯ `group by` columnï¼Œåœ¨åˆ†å¸ƒå¼åœºæ™¯å¦‚æœä¸æŠŠ `group by` column è¿”å›ï¼Œ`TiDB` æ²¡æœ‰åŠæ³•æ ¹æ®åˆ†ç»„åšäºŒæ¬¡èšåˆã€‚
    fn iterate_available_groups(
        &mut self,
        entities: &mut Entities<Src>,
        src_is_drained: bool,
        iteratee: impl FnMut(&mut Entities<Src>, &[Box<dyn AggrFunctionState>]) -> Result<()>,
    ) -> Result<Vec<LazyBatchColumn>>;
}

```

ä¸Šè¾¹ä»£ç ä¸­çš„ `Entities` æ˜¯è®°å½•æºç®—å­å·²ç»èšåˆå‡½æ•°å…ƒä¿¡æ¯çš„ä¸€ä¸ªç»“æ„ä½“ï¼š

```rust
pub struct Entities<Src: BatchExecutor> {
    pub src: Src,
    
    // ...

    // èšåˆåäº§ç”Ÿçš„ `schmea`ï¼Œ åŒ…å« `group_by` columns
    pub schema: Vec<FieldType>,

    /// èšåˆå‡½æ•°çš„é›†åˆ
    pub each_aggr_fn: Vec<Box<dyn AggrFunction>>,

    /// æ¯ä¸ªèšåˆå‡½æ•°è¾“å‡ºçš„åˆ—å¤§å°ï¼Œ`COUNT` æ˜¯ 1ï¼Œ`AVG` æ˜¯ 2
    pub each_aggr_cardinality: Vec<usize>,

    /// èšåˆå‡½æ•°é‡Œè¾¹çš„è¡¨è¾¾å¼
    pub each_aggr_exprs: Vec<RpnExpression>,

    // æ¯ä¸ªèšåˆè¡¨è¾¾å¼è¾“å‡ºçš„ç±»å‹çš„é›†åˆ
    pub all_result_column_types: Vec<EvalType>,
}

```

é¦–å…ˆï¼Œä¸ºäº†è§‚å¯Ÿåˆ° `BatchFastHashAggregationExecutor` æˆ‘ä»¬éœ€è¦è¿½è¸ªä»–çš„ `next_batch()` çš„å®ç°ï¼Œåœ¨è¿™é‡Œä¹Ÿå°±æ˜¯ï¼š `AggregationExecutor::handle_next_batch`ï¼š

```rust
    fn handle_next_batch(&mut self) -> Result<(Option<LazyBatchColumnVec>, bool)> {
        // ä»ä¸‹å±‚ç®—å­å–å›ä¸€ä¸ª `batch`
        let src_result = self
            .entities
            .src
            .next_batch(crate::batch:ğŸƒ:BATCH_MAX_SIZE);

        self.entities.context.warnings = src_result.warnings;

        let src_is_drained = src_result.is_drained?;

        // å¦‚æœä¸‹å±‚è¿”å›çš„æ•°æ®ä¸ä¸ºç©ºï¼Œå°†æ ¹æ®æ¯è¡Œçš„ç»“æœåˆ†ç»„å¹¶èšåˆ
        if !src_result.logical_rows.is_empty() {
            self.imp.process_batch_input(
                &mut self.entities,
                src_result.physical_columns,
                &src_result.logical_rows,
            )?;
        }

        // åœ¨ `FastHashAggr` ä¸­ï¼Œåªæœ‰ä¸‹å±‚ç®—å­æ²¡æœ‰åŠæ³•å†è¿”å›æ•°æ®çš„æ—¶å€™ï¼Œæ‰èƒ½è®¤ä¸ºèšåˆå·²ç»å®Œæˆï¼Œ
        // å¦åˆ™æˆ‘ä»¬è¿”å›ä¸€ä¸ªç©ºæ•°æ®ç»™ä¸Šå±‚ç®—å­ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ `next_batch` è¢«è°ƒç”¨ã€‚
        let result = if src_is_drained {
            Some(self.aggregate_partial_results(src_is_drained)?)
        } else {
            None
        };
        Ok((result, src_is_drained))
    }

```

å…·ä½“åˆ° `FastHashAggr` ä¸­ï¼Œ`process_batch_input` å°±æ˜¯åˆ†ç»„å¹¶æ›´æ–°æ¯ç»„çš„çŠ¶æ€ã€‚`aggregate_partial_results` å°±æ˜¯å†™å…¥æœ€ç»ˆçš„çŠ¶æ€åˆ°åˆ—æ•°ç»„ä¸­ã€‚

## æ€»ç»“

æœ¬æ–‡ç®€ç•¥çš„ä»‹ç»äº† TiKV æŸ¥è¯¢å¼•æ“çš„å®ç°åŸç†å’Œå‡ ä¸ªç®€å•ç®—å­çš„å®ç°ï¼Œå¦‚æœå¤§å®¶å¯¹å…¶ä»–ç®—å­ä¹Ÿæ„Ÿå…´è¶£çš„è¯ï¼Œå¯ä»¥åˆ° [tikv/components/tidb_query/src/batch/executors](https://github.com/tikv/tikv/tree/983c626b069f2a2314d0a47009ca74033b346069/components/tidb_query/src/batch/executors) ä¸‹è¾¹æ‰¾åˆ°å¯¹åº”çš„å®ç°ï¼Œæœ¬æ–‡ä¸­å‡ºç°çš„ä»£ç éƒ½ç»è¿‡ä¸€å®šåˆ å‡ï¼Œæ¬¢è¿å¤§å®¶é˜…è¯» TiKV çš„æºç è·å–æ›´å¤šçš„ç»†èŠ‚ã€‚